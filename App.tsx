import React, { useState, useEffect } from 'react';
import { GoogleGenAI, Type } from "@google/genai";
import Header from './components/Header.tsx';
import CreatePollForm from './components/CreatePollForm.tsx';
import PollCard from './components/PollCard.tsx';
import { Poll, Comment as CommentData, CommentType } from './types.ts';

// FIX: Initialize GoogleGenAI with named apiKey parameter using process.env.API_KEY.
const ai = new GoogleGenAI({ apiKey: import.meta.env.VITE_GOOGLE_API_KEY as string });

const App: React.FC = () => {
  const [polls, setPolls] = useState<Poll[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [votedPolls, setVotedPolls] = useState<Set<number>>(() => {
    const saved = localStorage.getItem('votedPolls');
    return saved ? new Set(JSON.parse(saved)) : new Set();
  });
  const [upvotedComments, setUpvotedComments] = useState<Set<string>>(() => {
    const saved = localStorage.getItem('upvotedComments');
    return saved ? new Set(JSON.parse(saved)) : new Set();
  });
  const [downvotedComments, setDownvotedComments] = useState<Set<string>>(() => {
    const saved = localStorage.getItem('downvotedComments');
    return saved ? new Set(JSON.parse(saved)) : new Set();
  });
  const [likedPolls, setLikedPolls] = useState<Set<number>>(() => {
    const saved = localStorage.getItem('likedPolls');
    return saved ? new Set(JSON.parse(saved)) : new Set();
  });
  
  useEffect(() => {
    localStorage.setItem('votedPolls', JSON.stringify(Array.from(votedPolls)));
  }, [votedPolls]);

  useEffect(() => {
    localStorage.setItem('upvotedComments', JSON.stringify(Array.from(upvotedComments)));
  }, [upvotedComments]);

  useEffect(() => {
    localStorage.setItem('downvotedComments', JSON.stringify(Array.from(downvotedComments)));
  }, [downvotedComments]);

  useEffect(() => {
    localStorage.setItem('likedPolls', JSON.stringify(Array.from(likedPolls)));
  }, [likedPolls]);

  const handleCreatePoll = async (topic: string, description: string) => {
    setIsLoading(true);
    setError(null);
    try {
      const prompt = `
        For the debate topic "${topic}" with the description "${description}", 
        please generate 3 distinct arguments for the "pro" side and 3 distinct arguments for the "con" side.
        The arguments should be concise, well-reasoned, and presented from a neutral perspective as if generated by an AI assistant.
        Provide the output in JSON format.
      `;

      // FIX: Use ai.models.generateContent with the correct model and parameters according to guidelines.
      const response = await ai.models.generateContent({
  model: "gemini-1.5-flash", // 或 gemini-2.0-flash-preview，看你需要的模型
  contents: [
    {
      role: "user",
      parts: [
        { text: prompt }
      ]
    }
  ],
  config: {
    responseMimeType: "application/json",
    responseSchema: {
      type: Type.OBJECT,
      properties: {
        pro_arguments: {
          type: Type.ARRAY,
          items: { type: Type.STRING }
        },
        con_arguments: {
          type: Type.ARRAY,
          items: { type: Type.STRING }
        }
      },
      required: ["pro_arguments", "con_arguments"]
    }
  }
});

      
      // FIX: Access generated text directly from the 'text' property of the response.
      const jsonText = response.text;
      const generatedArguments = JSON.parse(jsonText);

      const newPoll: Poll = {
        id: Date.now(),
        topic,
        description,
        proVotes: 0,
        conVotes: 0,
        likes: 0,
        proComments: generatedArguments.pro_arguments.map((text: string, index: number) => ({
          id: Date.now() + index,
          text,
          author: 'AI Assistant',
          upvotes: 0,
          downvotes: 0,
        })),
        conComments: generatedArguments.con_arguments.map((text: string, index: number) => ({
          id: Date.now() + 1000 + index,
          text,
          author: 'AI Assistant',
          upvotes: 0,
          downvotes: 0,
        })),
      };

      setPolls(prevPolls => [newPoll, ...prevPolls]);

    } catch (e) {
      console.error(e);
      setError("無法生成論點，請稍後再試。");
    } finally {
      setIsLoading(false);
    }
  };

  const handleVote = (pollId: number, voteType: 'pro' | 'con') => {
    if (votedPolls.has(pollId)) return;
    
    setPolls(polls.map(p => {
      if (p.id === pollId) {
        return {
          ...p,
          proVotes: voteType === 'pro' ? p.proVotes + 1 : p.proVotes,
          conVotes: voteType === 'con' ? p.conVotes + 1 : p.conVotes,
        };
      }
      return p;
    }));
    
    setVotedPolls(prev => new Set(prev).add(pollId));
  };
  
  const handleLikePoll = (pollId: number) => {
    setPolls(polls.map(p => {
      if (p.id === pollId) {
        const isLiked = likedPolls.has(pollId);
        return {
          ...p,
          likes: isLiked ? p.likes - 1 : p.likes + 1,
        };
      }
      return p;
    }));

    setLikedPolls(prev => {
      const newLiked = new Set(prev);
      if (newLiked.has(pollId)) {
        newLiked.delete(pollId);
      } else {
        newLiked.add(pollId);
      }
      return newLiked;
    });
  };

  const handleAddComment = (pollId: number, commentType: CommentType, text: string) => {
    const newComment: CommentData = {
      id: Date.now(),
      text,
      author: '使用者',
      upvotes: 0,
      downvotes: 0,
    };
    
    setPolls(polls.map(p => {
      if (p.id === pollId) {
        if (commentType === CommentType.Pro) {
          return { ...p, proComments: [newComment, ...p.proComments] };
        } else {
          return { ...p, conComments: [newComment, ...p.conComments] };
        }
      }
      return p;
    }));
  };

  const handleVoteComment = (commentId: number, voteType: 'up' | 'down') => {
    let commentKey: string | null = null;
    
    const updatedPolls = polls.map(poll => {
      const findAndUpdateComment = (comments: CommentData[]) => {
        return comments.map(c => {
          if (c.id === commentId) {
            const currentKey = `${poll.id}-${c.id}`;
            commentKey = currentKey;

            const isUpvoted = upvotedComments.has(currentKey);
            const isDownvoted = downvotedComments.has(currentKey);

            let upvotes = c.upvotes;
            let downvotes = c.downvotes;

            if (voteType === 'up') {
              if (isUpvoted) {
                upvotes -= 1;
              } else {
                upvotes += 1;
                if (isDownvoted) {
                  downvotes -= 1;
                }
              }
            } else { // down
              if (isDownvoted) {
                downvotes -= 1;
              } else {
                downvotes += 1;
                if (isUpvoted) {
                  upvotes -= 1;
                }
              }
            }
            return { ...c, upvotes, downvotes };
          }
          return c;
        });
      };
      return {
        ...poll,
        proComments: findAndUpdateComment(poll.proComments),
        conComments: findAndUpdateComment(poll.conComments),
      };
    });

    setPolls(updatedPolls);
    
    if (commentKey) {
        const key = commentKey;
        const newUpvoted = new Set(upvotedComments);
        const newDownvoted = new Set(downvotedComments);

        if (voteType === 'up') {
            if (newUpvoted.has(key)) {
                newUpvoted.delete(key);
            } else {
                newUpvoted.add(key);
                newDownvoted.delete(key);
            }
        } else { // down
            if (newDownvoted.has(key)) {
                newDownvoted.delete(key);
            } else {
                newDownvoted.add(key);
                newUpvoted.delete(key);
            }
        }
        setUpvotedComments(newUpvoted);
        setDownvotedComments(newDownvoted);
    }
  };

  const handleUpvoteComment = (commentId: number) => handleVoteComment(commentId, 'up');
  const handleDownvoteComment = (commentId: number) => handleVoteComment(commentId, 'down');

  return (
    <div className="bg-slate-900 text-slate-100 min-h-screen font-sans">
      <Header />
      <main className="container mx-auto px-4 py-8">
        <div className="max-w-4xl mx-auto">
          <CreatePollForm onCreatePoll={handleCreatePoll} />
          {isLoading && <div className="text-center py-8 text-sky-400">正在生成 AI 論點...</div>}
          {error && <div className="text-center py-4 text-red-400 bg-red-900/50 rounded-lg my-4">{error}</div>}
          <div className="mt-12">
            {polls.map(poll => (
              <PollCard 
                key={poll.id} 
                poll={poll} 
                onVote={handleVote} 
                votedPolls={votedPolls}
                onAddComment={handleAddComment}
                upvotedComments={upvotedComments}
                downvotedComments={downvotedComments}
                onUpvoteComment={handleUpvoteComment}
                onDownvoteComment={handleDownvoteComment}
                isLiked={likedPolls.has(poll.id)}
                onLike={handleLikePoll}
              />
            ))}
          </div>
        </div>
      </main>
    </div>
  );
};

export default App;
